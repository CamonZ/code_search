# code_search

A CLI tool for querying Elixir/Erlang call graph data stored in CozoDB. Designed for LLMs to efficiently explore and understand codebases without consuming context windows by reading source files directly.

## Why?

When LLMs analyze codebases, they typically read source files one by one, quickly exhausting their context window. This tool provides structured queries over pre-extracted call graph data, allowing LLMs to:

- Find function definitions and their locations
- Trace call chains (who calls what, and who calls them)
- Discover module dependencies
- Identify unused code, hotspots, and code smells
- Search by pattern without reading files

One query can answer questions that would otherwise require reading dozens of files.

## Installation

```bash
cargo build --release
```

## Quick Start

First, import a call graph JSON file (generated by an Elixir analyzer):

```bash
code_search import --file call_graph.json
```

Then query the data:

```bash
# Find where a function is defined
code_search location get_user MyApp.Accounts

# What does this function call?
code_search calls-from MyApp.Accounts get_user

# Who calls this function?
code_search calls-to MyApp.Repo get

# Trace the full call chain from a function
code_search trace MyApp.Web.UserController show

# Find unused functions
code_search unused -P

# Find hotspots (most called functions)
code_search hotspots -l 10
```

## Output Formats

All commands support three output formats via `--format` or `-o`:

- `table` (default): Human-readable output for terminal use
- `json`: Structured JSON for programmatic use
- `toon`: Token-optimized format for LLM consumption (minimal tokens while preserving structure)

## Commands

Use `code_search describe` to see detailed documentation, or `code_search describe <command>` for specific command help.

### Query Commands

| Command | Usage | Description |
|---------|-------|-------------|
| `calls-to` | `calls-to <MODULE> [FUNCTION] [ARITY]` | Find what calls a function |
| `calls-from` | `calls-from <MODULE> [FUNCTION] [ARITY]` | Find what a function calls |
| `trace` | `trace <MODULE> <FUNCTION>` | Forward call chain traversal |
| `reverse-trace` | `reverse-trace <MODULE> <FUNCTION>` | Backward call chain traversal |
| `path` | `path --from-module M --from-function F --to-module M --to-function F` | Find call path between two functions |

### Search Commands

| Command | Usage | Description |
|---------|-------|-------------|
| `search` | `search <PATTERN> [-k modules\|functions]` | Search modules/functions by name |
| `location` | `location <FUNCTION> [MODULE]` | Find function definition location |
| `function` | `function <MODULE> <FUNCTION>` | Show function signature |
| `browse-module` | `browse-module <MODULE>` | List all definitions in a module |

### Type Search Commands

| Command | Usage | Description |
|---------|-------|-------------|
| `accepts` | `accepts <PATTERN> [MODULE]` | Find functions accepting a type |
| `returns` | `returns <PATTERN> [MODULE]` | Find functions returning a type |
| `struct-usage` | `struct-usage <PATTERN> [MODULE]` | Find functions using a type |

### Module Commands

| Command | Usage | Description |
|---------|-------|-------------|
| `depends-on` | `depends-on <MODULE>` | Show module's outgoing dependencies |
| `depended-by` | `depended-by <MODULE>` | Show module's incoming dependencies |
| `clusters` | `clusters [MODULE]` | Analyze namespace-based clustering |
| `cycles` | `cycles [MODULE]` | Detect circular dependencies |

### Analysis Commands

| Command | Usage | Description |
|---------|-------|-------------|
| `hotspots` | `hotspots [MODULE] [-k incoming\|outgoing\|total\|ratio]` | Find high-connectivity functions |
| `unused` | `unused [MODULE] [-p\|-P]` | Find uncalled functions |
| `boundaries` | `boundaries [MODULE]` | Find boundary modules (high fan-in, low fan-out) |
| `god-modules` | `god-modules [MODULE]` | Find modules with high function count and connectivity |
| `duplicates` | `duplicates [MODULE]` | Find duplicate function implementations |
| `complexity` | `complexity [MODULE]` | Display cyclomatic complexity metrics |
| `large-functions` | `large-functions [MODULE]` | Find functions with many lines |
| `many-clauses` | `many-clauses [MODULE]` | Find functions with many pattern-matched heads |

### Other Commands

| Command | Usage | Description |
|---------|-------|-------------|
| `setup` | `setup` | Create database schema |
| `import` | `import --file <FILE>` | Import call graph JSON |
| `describe` | `describe [COMMANDS...]` | Show detailed command documentation |

## Common Options

Most commands support these options:

- `-l, --limit <N>`: Maximum results to return (default: 100, max: 1000)
- `-r, --regex`: Treat patterns as regular expressions
- `--project <NAME>`: Filter to a specific project (default: "default")
- `-d, --db <PATH>`: Database file path (default: ./cozo.sqlite)
- `-o, --format <FORMAT>`: Output format (table, json, toon)

## Examples

```bash
# Find all functions that accept a User.t type
code_search accepts "User.t"

# Find modules with circular dependencies
code_search cycles MyApp.Core

# Find the most complex functions in a namespace
code_search complexity MyApp.Accounts --min 10

# Trace how a controller action flows through the codebase
code_search trace MyApp.Web.UserController create --depth 10

# Find all paths from an API endpoint to a database call
code_search path --from-module MyApp.API --from-function create_user \
                 --to-module MyApp.Repo --to-function insert

# Find god modules (too large, too connected)
code_search god-modules --min-functions 30 --min-loc 500

# Find boundary modules that many depend on
code_search boundaries --min-ratio 3.0
```

## Architecture

- Written in Rust using clap for CLI parsing
- Uses CozoDB (SQLite-backed) for graph queries
- Call graph data is extracted separately by an Elixir analyzer
- Supports multiple projects in the same database via `--project` flag
